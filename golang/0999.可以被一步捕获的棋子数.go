/*
 * @lc app=leetcode.cn id=999 lang=golang
 *
 * [999] 可以被一步捕获的棋子数
 *
 * https://leetcode.cn/problems/available-captures-for-rook/description/
 *
 * algorithms
 * Easy (69.69%)
 * Likes:    118
 * Dislikes: 0
 * Total Accepted:    39.8K
 * Total Submissions: 56.6K
 * Testcase Example:  '[[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","R",".",".",".","p"],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]]'
 *
 * 给定一个 8 x 8 的棋盘，只有一个 白色的车，用字符 'R' 表示。棋盘上还可能存在白色的象 'B' 以及黑色的卒 'p'。空方块用字符 '.'
 * 表示。
 *
 * 车可以按水平或竖直方向（上，下，左，右）移动任意个方格直到它遇到另一个棋子或棋盘的边界。如果它能够在一次移动中移动到棋子的方格，则能够 吃掉 棋子。
 *
 * 注意：车不能穿过其它棋子，比如象和卒。这意味着如果有其它棋子挡住了路径，车就不能够吃掉棋子。
 *
 * 返回白车将能 吃掉 的 卒的数量。
 *
 *
 *
 * 示例 1：
 *
 *
 *
 *
 *
 * 输入：[[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","R",".",".",".","p"],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]]
 * 输出：3
 * 解释：
 * 在本例中，车能够吃掉所有的卒。
 *
 *
 * 示例 2：
 *
 *
 *
 *
 *
 * 输入：[[".",".",".",".",".",".",".","."],[".","p","p","p","p","p",".","."],[".","p","p","B","p","p",".","."],[".","p","B","R","B","p",".","."],[".","p","p","B","p","p",".","."],[".","p","p","p","p","p",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]]
 * 输出：0
 * 解释：
 * 象阻止了车吃掉任何卒。
 *
 *
 * 示例 3：
 *
 *
 *
 *
 *
 * 输入：[[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","p",".",".",".","."],["p","p",".","R",".","p","B","."],[".",".",".",".",".",".",".","."],[".",".",".","B",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."]]
 * 输出：3
 * 解释：
 * 车可以吃掉位置 b5，d6 和 f5 的卒。
 *
 *
 *
 *
 * 提示：
 *
 *
 * board.length == 8
 * board[i].length == 8
 * board[i][j] 可以是 'R'，'.'，'B' 或 'p'
 * 只有一个格子上存在 board[i][j] == 'R'
 *
 *
 */

// @lc code=start
package main

var directions = []struct{ x, y int }{{0, -1}, {0, 1}, {-1, 0}, {1, 0}}

func numRookCaptures(board [][]byte) int {
	const size = 8
	var px, py int

	for i, row := range board {
		for j, c := range row {
			if c == 'R' {
				px, py = i, j
			}
		}
	}

	count := 0
	for _, d := range directions {
		x, y := px+d.x, py+d.y
		for 0 <= x && x < size && 0 <= y && y < size && board[x][y] == '.' {
			x += d.x
			y += d.y
		}

		if 0 <= x && x < size && 0 <= y && y < size && board[x][y] == 'p' {
			count++
		}
	}

	return count
}

// @lc code=end
